"""
APScheduler Í∏∞Î∞ò Ïä§ÏºÄÏ§ÑÎü¨

ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú ÌÅ¨Î°† Î∞è ÌÉÄÏûÑÏ°¥ÏùÑ ÏÑ§Ï†ïÌï† Ïàò ÏûàÏúºÎ©∞,
Í∏∞Î≥∏Í∞íÏùÄ Í∞Å Íµ≠Í∞Ä Ïû• ÎßàÍ∞ê Ïù¥ÌõÑ(ÌèâÏùº)Î°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.

ENV
- SCHEDULE_ENABLE_KOR/AUS/COIN: "1"/"0" (Í∏∞Î≥∏ 1)
- SCHEDULE_KOR_CRON: Í∏∞Î≥∏ "10 18 * * 1-5" (18:10, ÌèâÏùº)
- SCHEDULE_AUS_CRON: Í∏∞Î≥∏ "10 18 * * 1-5"
- SCHEDULE_COIN_CRON: Í∏∞Î≥∏ "5 0 * * *" (Îß§Ïùº 00:05)
- SCHEDULE_KOR_TZ: Í∏∞Î≥∏ "Asia/Seoul"
- SCHEDULE_AUS_TZ: Í∏∞Î≥∏ "Australia/Sydney"
- SCHEDULE_COIN_TZ: Í∏∞Î≥∏ "Asia/Seoul"
- RUN_IMMEDIATELY_ON_START: "1" Ïù¥Î©¥ ÏãúÏûë Ïãú Ï¶âÏãú Ìïú Î≤à Ïã§Ìñâ
"""

import os
import logging
import sys
import time
from datetime import datetime

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏Î•º Python Í≤ΩÎ°úÏóê Ï∂îÍ∞Ä
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from apscheduler.schedulers.blocking import BlockingScheduler
from apscheduler.triggers.cron import CronTrigger

from utils.data_updater import update_etf_names

try:
    # DBÏóêÏÑú ÏÑ§Ï†ïÏùÑ ÏùΩÏñ¥ Ïä§ÏºÄÏ§Ñ Ï£ºÍ∏∞Î•º Ï†úÏñ¥
    from utils.db_manager import get_app_settings, get_common_settings
    from utils.env import load_env_if_present
except Exception:

    def get_common_settings():
        return None

    def get_app_settings(country):
        return None

    def load_env_if_present():
        return False


def setup_logging():
    """
    Î°úÍ∑∏ ÌååÏùºÏùÑ ÏÑ§Ï†ïÌï©ÎãàÎã§. logs/YYYY-MM-DD.log ÌòïÏãùÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§.
    ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä ÏãúÏûëÎê† ÎïåÏùò ÎÇ†ÏßúÎ•º Í∏∞Ï§ÄÏúºÎ°ú ÌååÏùºÎ™ÖÏù¥ Ï†ïÌï¥ÏßëÎãàÎã§.
    """
    # ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ ÏïÑÎûòÏóê logs ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
    log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "logs")
    os.makedirs(log_dir, exist_ok=True)

    # YYYY-MM-DD.log ÌååÏùºÎ™Ö ÏÑ§Ï†ï
    log_filename = os.path.join(log_dir, f"{datetime.now().strftime('%Y-%m-%d')}.log")

    # Î°úÍ±∞ ÏÑ§Ï†ï: ÌååÏùºÍ≥º ÏΩòÏÜîÏóê Î™®Îëê Ï∂úÎ†•
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(levelname)s - %(message)s",
        handlers=[
            logging.FileHandler(log_filename, encoding="utf-8"),
            logging.StreamHandler(sys.stdout),
        ],
    )


def _bool_env(name: str, default: bool = True) -> bool:
    v = os.environ.get(name)
    if v is None:
        return default
    return str(v).strip() not in ("0", "false", "False", "no", "NO")


def _get(name: str, default: str) -> str:
    return os.environ.get(name, default)


def _format_korean_datetime(dt: datetime) -> str:
    """ÎÇ†Ïßú-ÏãúÍ∞Ñ Í∞ùÏ≤¥Î•º 'YYYYÎÖÑ MMÏõî DDÏùº(ÏöîÏùº) Ïò§Ï†Ñ/Ïò§ÌõÑ HHÏãú MMÎ∂Ñ' ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÌï©ÎãàÎã§."""
    weekday_map = ["Ïõî", "Ìôî", "Ïàò", "Î™©", "Í∏à", "ÌÜ†", "Ïùº"]
    weekday_str = weekday_map[dt.weekday()]

    hour12 = dt.hour
    if hour12 >= 12:
        ampm_str = "Ïò§ÌõÑ"
        if hour12 > 12:
            hour12 -= 12
    else:
        ampm_str = "Ïò§Ï†Ñ"
    if hour12 == 0:
        hour12 = 12

    return f"{dt.strftime('%YÎÖÑ %mÏõî %dÏùº')}({weekday_str}) {ampm_str} {hour12}Ïãú {dt.minute:02d}Î∂Ñ"


def run_status(country: str) -> None:
    """Run status generation and sends a completion log to Slack."""
    start_time = time.time()
    report_date = None
    try:
        from status import main as run_status_main
        from utils.notify import send_log_to_slack
        from utils.db_manager import get_portfolio_snapshot, get_app_settings
        from utils.report import format_aud_money, format_kr_money

        # Get old equity
        old_snapshot = get_portfolio_snapshot(country)
        old_equity = float(old_snapshot.get("total_equity", 0.0)) if old_snapshot else 0.0

        logging.info(f"Running status for {country}")
        if country == "coin":
            _try_sync_bithumb_trades()
            # _try_sync_bithumb_equity()

        # status.mainÏùÄ ÏÑ±Í≥µ Ïãú Í≥ÑÏÇ∞Îêú Î¶¨Ìè¨Ìä∏Ïùò Í∏∞Ï§Ä ÎÇ†ÏßúÎ•º Î∞òÌôòÌï©ÎãàÎã§.
        report_date = run_status_main(country=country, date_str=None)

        # ÏûëÏóÖÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÍ≥† ÎÇ†ÏßúÎ•º Î∞õÏïÑÏôîÏùÑ ÎïåÎßå Î°úÍ∑∏ Ï†ÑÏÜ°
        if report_date:
            duration = time.time() - start_time
            date_str = report_date.strftime("%Y-%m-%d")
            message = f"{country}/{date_str} ÏûëÏóÖ ÏôÑÎ£å(ÏûëÏóÖÏãúÍ∞Ñ: {duration:.1f}Ï¥à)"

            # Get new equity
            new_snapshot = get_portfolio_snapshot(country)
            new_equity = float(new_snapshot.get("total_equity", 0.0)) if new_snapshot else 0.0

            # Calculate cumulative return
            app_settings = get_app_settings(country)
            initial_capital = float(app_settings.get("initial_capital", 0)) if app_settings else 0.0

            money_formatter = format_aud_money if country == "aus" else format_kr_money

            if initial_capital > 0:
                cum_ret_pct = ((new_equity / initial_capital) - 1.0) * 100.0
                cum_profit_loss = new_equity - initial_capital
                equity_summary = f"ÌèâÍ∞ÄÍ∏àÏï°: {money_formatter(new_equity)}, ÎàÑÏ†ÅÏàòÏùµ {cum_ret_pct:+.2f}%({money_formatter(cum_profit_loss)})"
                message += f" | {equity_summary}"

            if abs(new_equity - old_equity) > 1e-9:
                diff = new_equity - old_equity
                diff_str = f"{'+' if diff > 0 else ''}{money_formatter(diff)}"
                change_label = "üìàÌèâÍ∞ÄÍ∏àÏï° Ï¶ùÍ∞Ä" if diff >= 0 else "üìâÌèâÍ∞ÄÍ∏àÏï° Í∞êÏÜå"
                equity_change_message = f"{change_label}: {money_formatter(old_equity)} => {money_formatter(new_equity)} ({diff_str})"
                message += f" | {equity_change_message}"

            send_log_to_slack(message)

    except Exception:
        error_message = f"Status job for {country} failed"
        logging.error(error_message, exc_info=True)


def _try_sync_bithumb_equity():
    """
    ÏΩîÏù∏(Bithumb) ÏûîÏï°ÏùÑ Ïä§ÎÉÖÏÉ∑ÌïòÍ≥†, Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ Ïä¨ÎûôÏúºÎ°ú ÏïåÎ¶ºÏùÑ Î≥¥ÎÉÖÎãàÎã§.
    """
    try:
        from scripts.snapshot_bithumb_balances import main as snapshot_main
        from status import _notify_equity_update
        from utils.db_manager import get_portfolio_snapshot, save_daily_equity

        # 1. ÏóÖÎç∞Ïù¥Ìä∏ Ï†Ñ ÌòÑÏû¨ ÌèâÍ∞ÄÍ∏àÏï°ÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
        old_snapshot = get_portfolio_snapshot("coin")
        old_equity = float(old_snapshot.get("total_equity", 0.0)) if old_snapshot else 0.0

        # 2. ÎπóÏç∏ ÏûîÏï° Ïä§ÎÉÖÏÉ∑ Ïä§ÌÅ¨Î¶ΩÌä∏Î•º Ïã§ÌñâÌïòÏó¨ DBÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
        logging.info("Starting Bithumb balance snapshot...")
        snapshot_main()
        logging.info("Bithumb balance snapshot finished.")

        # 3. ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ ÏÉàÎ°úÏö¥ ÌèâÍ∞ÄÍ∏àÏï°ÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
        new_snapshot = get_portfolio_snapshot("coin")
        new_equity = float(new_snapshot.get("total_equity", 0.0)) if new_snapshot else 0.0

        # 4. Ïä§ÏºÄÏ§ÑÎü¨Ïóê ÏùòÌïú ÏóÖÎç∞Ïù¥Ìä∏ÏûÑÏùÑ Í∏∞Î°ùÌïòÍ∏∞ ÏúÑÌï¥ `updated_by`ÏôÄ Ìï®Íªò Ìï≠ÏÉÅ Ï†ÄÏû•Ìï©ÎãàÎã§.
        if new_snapshot:
            save_daily_equity("coin", new_snapshot["date"], new_equity, updated_by="Ïä§ÏºÄÏ§ÑÎü¨")
            logging.info("-> Coin equity snapshot updated. (updated_by='scheduler')")

            # 5. ÌèâÍ∞ÄÍ∏àÏï°Ïù¥ Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏ÌïòÍ≥†, Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ Ïä¨Îûô ÏïåÎ¶ºÏùÑ Î≥¥ÎÉÖÎãàÎã§.
            if abs(new_equity - old_equity) > 1e-9:
                logging.info(
                    f"-> Coin equity change detected: {old_equity:,.0f} -> {new_equity:,.0f}. Sending notification."
                )
                _notify_equity_update("coin", old_equity, new_equity)
            else:
                logging.info("-> No change in coin equity.")
        else:
            logging.warning("-> Coin equity snapshot not found, skipping update.")

    except Exception:
        error_message = "Bithumb balance snapshot skipped or failed"
        logging.error(error_message, exc_info=True)


def _try_sync_bithumb_trades():
    """If coin: sync Bithumb accounts ‚Üí trades before status run."""
    try:
        from scripts.sync_bithumb_accounts_to_trades import main as sync_main

        sync_main()
    except Exception:
        error_message = "Bithumb accounts->trades sync skipped or failed"
        logging.error(error_message, exc_info=True)


def main():
    # Î°úÍπÖ ÏÑ§Ï†ï
    setup_logging()

    # Load .env for API keys, DB, etc.
    load_env_if_present()

    # Update stock names before scheduling
    logging.info("Checking for and updating stock names...")
    try:
        update_etf_names()
        logging.info("Stock name update complete.")
    except Exception as e:
        logging.error(f"Failed to update stock names: {e}", exc_info=True)

    scheduler = BlockingScheduler()

    # Í≥µÌÜµ ÏÑ§Ï†ïÏóêÏÑú Ïä§ÏºÄÏ§Ñ Ï£ºÍ∏∞(ÏãúÍ∞Ñ) ÏùΩÍ∏∞
    common = get_common_settings() or {}
    # coin
    if _bool_env("SCHEDULE_ENABLE_COIN", True):
        # DBÏùò ÌÅ¨Î°† ÏÑ§Ï†ïÏùÑ Ïö∞ÏÑ† ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ ÌôòÍ≤ΩÎ≥ÄÏàò Ìè¥Î∞±
        cron = common.get("SCHEDULE_CRON_COIN") or _get("SCHEDULE_COIN_CRON", "5 0 * * *")
        tz = _get("SCHEDULE_COIN_TZ", "Asia/Seoul")
        scheduler.add_job(
            run_status,
            CronTrigger.from_crontab(cron, timezone=tz),
            args=["coin"],
            id="coin",
        )
        logging.info(f"Scheduled COIN: cron='{cron}' tz='{tz}'")

    # aus
    if _bool_env("SCHEDULE_ENABLE_AUS", True):
        cron = common.get("SCHEDULE_CRON_AUS") or _get("SCHEDULE_AUS_CRON", "10 18 * * 1-5")
        tz = _get("SCHEDULE_AUS_TZ", "Australia/Sydney")
        scheduler.add_job(
            run_status,
            CronTrigger.from_crontab(cron, timezone=tz),
            args=["aus"],
            id="aus",
        )
        logging.info(f"Scheduled AUS: cron='{cron}' tz='{tz}'")

    # kor
    if _bool_env("SCHEDULE_ENABLE_KOR", True):
        cron = common.get("SCHEDULE_CRON_KOR") or _get("SCHEDULE_KOR_CRON", "10 18 * * 1-5")
        tz = _get("SCHEDULE_KOR_TZ", "Asia/Seoul")
        scheduler.add_job(
            run_status,
            CronTrigger.from_crontab(cron, timezone=tz),
            args=["kor"],
            id="kor",
        )
        logging.info(f"Scheduled KOR: cron='{cron}' tz='{tz}'")

    if _bool_env("RUN_IMMEDIATELY_ON_START", False):
        # ÏãúÏûë Ïãú Ìïú Î≤à Ï¶âÏãú Ïã§Ìñâ
        logging.info("\n[Initial Run] Starting...")
        # run_status("aus")
        for country in ("coin", "aus", "kor"):
            try:
                if _bool_env(f"SCHEDULE_ENABLE_{country.upper()}", True):
                    run_status(country)
            except Exception:
                logging.error(f"Error during initial run for {country}", exc_info=True)
        logging.info("[Initial Run] Complete.")

    # Îã§Ïùå Ïã§Ìñâ ÏãúÍ∞Ñ Ï∂úÎ†•
    jobs = scheduler.get_jobs()
    if jobs:
        logging.info("\nNext scheduled run times:")
        for job in jobs:
            # 3.x: job.next_run_time
            next_time = getattr(job, "next_run_time", None)

            # 4.x (ÌòπÏãú Î™®Î•¥Í≤å ÌòºÌï©Îêú Í≤ΩÏö∞): triggerÏóêÏÑú ÏßÅÏ†ë Íµ¨ÌïòÍ∏∞
            if next_time is None and hasattr(job, "trigger"):
                next_time = job.trigger.get_next_fire_time(None, datetime.now())

            if next_time:
                logging.info(f"- {job.id}: {_format_korean_datetime(next_time)}")
            else:
                logging.info(f"- {job.id}: No scheduled runs")
    logging.info("\nStarting scheduler. Waiting for the next job...")
    scheduler.start()


if __name__ == "__main__":
    main()
