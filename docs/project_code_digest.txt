================================================================================
MOMENTUM-ETF í”„ë¡œì íŠ¸ í•µì‹¬ ì½”ë“œ ë‹¤ì´ì œìŠ¤íŠ¸ (Core Files Only)
ìƒì„±ì¼: 2026-02-16
íŒŒì¼: config.py, strategies/maps/*.py
================================================================================

[ì „ì²´ íŒŒì¼ êµ¬ì¡°]
./Dockerfile
./LICENSE
./README.md
./all.py
./app.py
./app_pages
./app_pages/account_page.py
./app_pages/admin_page.py
./app_pages/all_stocks.py
./app_pages/stocks.py
./aps.py
./backtest.py
./config.py
./docker-compose.yml
./docs
./docs/developer_guide.md
./docs/project_code_digest.txt
./docs/project_overview.md
./docs/strategy_logic.md
./docs/user_guide.md
./logic
./logic/__init__.py
./logic/backtest
./logic/backtest/__init__.py
./logic/backtest/account.py
./logic/backtest/engine.py
./logic/backtest/filtering.py
./logic/backtest/notes.py
./logic/backtest/portfolio.py
./logic/backtest/price.py
./logic/backtest/reporting.py
./logic/backtest/signals.py
./logic/entry_point.py
./logic/tune
./logic/tune/__init__.py
./logic/tune/runner.py
./logs
./pyproject.toml
./recommend.py
./requirements-dev.in
./requirements-dev.txt
./requirements.in
./requirements.txt
./run.py
./scripts
./scripts/add_meta_tags.py
./scripts/analyze_removed_ytd.py
./scripts/check_similar_tickers.py
./scripts/collect_investor_trend.py
./scripts/find_kor.py
./scripts/find_removed_stocks.py
./scripts/find_us.py
./scripts/migrate_stocks_to_db.py
./scripts/results
./scripts/results/investor_trend_2026-02-05.log
./scripts/results/investor_trend_2026-02-06.log
./scripts/run_stock_stats_update.py
./scripts/stock_meta_updater.py
./scripts/update_app_datetime.sh
./scripts/update_price_cache.py
./static
./static/og-image.png
./strategies
./strategies/__init__.py
./strategies/maps
./strategies/maps/__init__.py
./strategies/maps/backtest.py
./strategies/maps/constants.py
./strategies/maps/evaluator.py
./strategies/maps/formatting.py
./strategies/maps/history.py
./strategies/maps/labeler.py
./strategies/maps/messages.py
./strategies/maps/metrics.py
./strategies/maps/rules.py
./strategies/maps/scoring.py
./strategies/rsi
./strategies/rsi/__init__.py
./strategies/rsi/backtest.py
./strategies/rsi/recommend.py
./strategies/rsi/scoring.py
./tools
./tools/generate_password.py
./tune.py
./utils
./utils/account_registry.py
./utils/cache_utils.py
./utils/caching.py
./utils/country_registry.py
./utils/cron_utils.py
./utils/data_loader.py
./utils/db_manager.py
./utils/edit.py
./utils/env.py
./utils/formatters.py
./utils/indicators.py
./utils/logger.py
./utils/market_schedule.py
./utils/meta_tags.py
./utils/moving_averages.py
./utils/notification.py
./utils/recommendation_storage.py
./utils/recommendations.py
./utils/report.py
./utils/schedule_config.py
./utils/settings_loader.py
./utils/stock_list_io.py
./utils/stock_meta_updater.py
./utils/strategy_validator.py
./utils/ui.py
./zaccounts
./znotes

================================================================================
=== config.py ===
"""í”„ë¡œì íŠ¸ ì „ì—­ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì„¤ì • ê°’ ì •ì˜."""

CACHE_START_DATE = "2024-01-02"


# ë„¤ì´ë²„ ê¸ˆìœµ API ì„¤ì •
NAVER_FINANCE_ETF_API_URL = "https://finance.naver.com/api/sise/etfItemList.nhn"
NAVER_FINANCE_CHART_API_URL = "https://fchart.stock.naver.com/sise.nhn"
NAVER_FINANCE_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
    "Referer": "https://finance.naver.com/sise/etfList.nhn",
    "Accept": "application/json, text/plain, */*",
}

# í˜¸ì£¼ MarketIndex QuoteAPI ì„¤ì •
AU_QUOTEAPI_URL = "https://quoteapi.com/api/v5/symbols"
AU_QUOTEAPI_APP_ID = "af5f4d73c1a54a33"  # marketindex.com.au ì œê³µ
AU_QUOTEAPI_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
    "Referer": "https://www.marketindex.com.au/",
    "Origin": "https://www.marketindex.com.au",
}

# RSI ê³„ì‚° íŒŒë¼ë¯¸í„° (ì›ë³¸ RSI ì‚¬ìš©: 70 ì´ìƒ ê³¼ë§¤ìˆ˜, 30 ì´í•˜ ê³¼ë§¤ë„)
RSI_CALCULATION_CONFIG = {
    "period": 15,
    "ema_smoothing": 2.0,
}


# í†µí•© ì‹œì¥ ê±°ë˜ ì‹œê°„í‘œ
from datetime import time

MARKET_SCHEDULES = {
    "kor": {
        "open": time(9, 0),
        "close": time(15, 30),
        "open_offset_minutes": 30,
        "close_offset_minutes": 30,
        "timezone": "Asia/Seoul",
    },
    "us": {
        "open": time(9, 30),
        "close": time(16, 0),
        "open_offset_minutes": 30,
        "close_offset_minutes": 30,
        "timezone": "America/New_York",
    },
    "au": {
        "open": time(10, 0),
        "close": time(16, 0),
        "open_offset_minutes": 30,
        "close_offset_minutes": 30,
        "timezone": "Australia/Sydney",
    },
}

# ë°±í…ŒìŠ¤íŠ¸ ì²´ê²° ìŠ¬ë¦¬í”¼ì§€ ê°€ì •ì¹˜ (%)
BACKTEST_SLIPPAGE = {
    "kor": {
        "buy_pct": 0.5,
        "sell_pct": 0.5,
    },
    "us": {
        "buy_pct": 0.25,
        "sell_pct": 0.25,
    },
    "au": {
        "buy_pct": 1.0,
        "sell_pct": 1.0,
    },
}

# 1ê°œì›” = 20 ê±°ë˜ì¼ (MA ê°œì›” â†’ ê±°ë˜ì¼ ë³€í™˜ì— ì‚¬ìš©)
TRADING_DAYS_PER_MONTH = 20

# ì§€í‘œ ê³„ì‚°ì— í•„ìš”í•œ ì ˆëŒ€ ìµœì†Œ ê±°ë˜ì¼ ìˆ˜ (MA íƒ€ì… ë¬´ê´€, í•­ìƒ ì ìš©)
# ENABLE_DATA_SUFFICIENCY_CHECK = True  â†’ MA íƒ€ì…ë³„ ì—„ê²© ê¸°ì¤€ ì ìš© (60~120ì¼)
# ENABLE_DATA_SUFFICIENCY_CHECK = False â†’ ì´ ê°’ë§Œ ì²´í¬ (ì‹ ê·œ ìƒì¥ ETF ì¡°ê¸° í¬ì°©ìš©)
# 5ì¼(1ì£¼) ë¯¸ë§Œ ë°ì´í„°ëŠ” ì¶”ì„¸ íŒë‹¨ì´ ë¶ˆê°€í•˜ë¯€ë¡œ ì œì™¸
MIN_TRADING_DAYS = 5




# [ì „ëµ ì‹¤í–‰ ì‹œ ì‹¤ì‹œê°„ ê°€ê²© ë°˜ì˜ ì—¬ë¶€]
# True: ì¥ì¤‘ ì‹¤í–‰ ì‹œ í˜„ì¬ê°€(ì‹¤ì‹œê°„)ë¥¼ 'ì˜¤ëŠ˜ ì¢…ê°€'ë¡œ ê°€ì •í•˜ê³  ì „ëµ ì‹¤í–‰ (ìˆœìœ„ ë³€ë™ ë°œìƒ ê°€ëŠ¥)
# False: ì¥ì¤‘ ì‹¤í–‰ ì‹œ 'ì–´ì œ ì¢…ê°€'ê¹Œì§€ë§Œ ì „ëµì— ë°˜ì˜ (ìˆœìœ„ ê³ ì •), ìˆ˜ìµë¥ ë§Œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (ê¶Œì¥)
USE_REALTIME_RECOMMENDATION = False
=== strategies/maps/constants.py ===
"""MAPS(Moving Average Position Score) ì „ëµì—ì„œ ì‚¬ìš©í•˜ëŠ” ìƒìˆ˜ ëª¨ìŒ."""

from __future__ import annotations

DECISION_CONFIG = {
    "HOLD": {
        "display_name": "<ğŸ’¼ ë³´ìœ >",
        "order": 10,
        "is_recommendation": False,
        "show_slack": True,
        # [User Request] ë³´ìœ  ì¢…ëª© í•˜ì´ë¼ì´íŠ¸ (ì—°í•œ ì´ˆë¡)
        "background": "#d0f0c0",
    },
    "CUT_STOPLOSS": {
        "display_name": "<ğŸš¨ ì†ì ˆë§¤ë„>",
        "order": 11,
        "is_recommendation": True,
        "show_slack": True,
    },
    "SELL_TREND": {
        "display_name": "<ğŸ“‰ ì¶”ì„¸ì´íƒˆ ë§¤ë„>",
        "order": 21,
        "is_recommendation": True,
        "show_slack": True,
    },
    "SELL_RSI": {
        "display_name": "<ğŸ”¥ RSI ê³¼ë§¤ìˆ˜ ë§¤ë„>",
        "order": 22,
        "is_recommendation": True,
        "show_slack": True,
        "background": "#ffb6c1",
    },
    "BUY_REPLACE": {
        "display_name": "<ğŸ”„ êµì²´ë§¤ìˆ˜>",
        "order": 25,
        "is_recommendation": True,
        "show_slack": True,
        "background": "#81c147",
    },
    "SELL_REPLACE": {
        "display_name": "<ğŸ”„ êµì²´ë§¤ë„>",
        "order": 26,
        "is_recommendation": True,
        "show_slack": True,
        "background": "#ffc1cc",
    },
    "BUY": {
        "display_name": "<ğŸš€ ì‹ ê·œë§¤ìˆ˜>",
        "order": 31,
        "is_recommendation": True,
        "show_slack": True,
        "background": "#81c147",
    },
    "WAIT": {
        "display_name": "<â³ ëŒ€ê¸°>",
        "order": 50,
        "is_recommendation": False,
        "show_slack": False,
        "background": "#f0f0f0",
    },
    "SOLD": {
        "display_name": "<âœ… ë§¤ë„ ì™„ë£Œ>",
        "order": 100,
        "is_recommendation": False,
        "show_slack": True,
        "background": "#a0a0a0",
    },
}


def _normalize_display_label(raw: str | None) -> str:
    value = str(raw or "").strip()
    if value.startswith("<") and value.endswith(">"):
        value = value[1:-1].strip()
    return value


_DECISION_MESSAGE_OVERRIDES: dict[str, str] = {
    "BUY": "âœ… ì‹ ê·œ ë§¤ìˆ˜",
    "SOLD": "ğŸ”š ë§¤ë„ ì™„ë£Œ",
    "BUY_REPLACE": "ğŸ”„ êµì²´ë§¤ìˆ˜",
    "SELL_REPLACE": "ğŸ”„ êµì²´ë§¤ë„",
    "SELL_RSI": "ğŸ”¥ RSI ê³¼ë§¤ìˆ˜ ë§¤ë„",
}


DECISION_MESSAGES = {
    key: _normalize_display_label(cfg.get("display_name"))
    for key, cfg in DECISION_CONFIG.items()
    if isinstance(cfg, dict) and cfg.get("display_name")
}

for override_key, override_value in _DECISION_MESSAGE_OVERRIDES.items():
    DECISION_MESSAGES[override_key] = override_value

DECISION_MESSAGES = {key: value for key, value in DECISION_MESSAGES.items() if value}

DECISION_MESSAGES["NEW_BUY"] = DECISION_MESSAGES.get("BUY", "âœ… ì‹ ê·œ ë§¤ìˆ˜")

DECISION_NOTES = {
    "INSUFFICIENT_CASH": "í˜„ê¸ˆ ë¶€ì¡±",
    "NO_PRICE": "ê°€ê²© ì •ë³´ ì—†ìŒ",
    "TREND_BREAK": "ì¶”ì„¸ ì´íƒˆ",
    "REPLACE_SELL": "êµì²´ ë§¤ë„",
    "PRICE_DATA_FAIL": "ê°€ê²© ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨",
    "REPLACE_SCORE": "êµì²´ {replace_score:.1f}ì ìˆ˜ ë¯¸ë§Œ",
    "DATA_INSUFFICIENT": "âš ï¸ ê±°ë˜ì¼ ë¶€ì¡±",
    # í…œí”Œë¦¿
    "COOLDOWN_GENERIC": "ì¿¨ë‹¤ìš´ {days}ì¼ ëŒ€ê¸°ì¤‘",
}

__all__ = [
    "DECISION_CONFIG",
    "DECISION_MESSAGES",
    "DECISION_NOTES",
]
=== strategies/maps/rules.py ===
"""Momentum ì „ëµì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê·œì¹™/ê²€ì¦ í—¬í¼."""

from __future__ import annotations

from collections.abc import Mapping
from dataclasses import dataclass
from typing import Any

from config import TRADING_DAYS_PER_MONTH


@dataclass(frozen=True)
class StrategyRules:
    """Momentum ì „ëµì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” í•µì‹¬ íŒŒë¼ë¯¸í„°."""

    # ê¸°ë³¸ MA íƒ€ì… (ì´ë™í‰ê·  ì¢…ë¥˜)
    DEFAULT_MA_TYPE = "SMA"

    ma_days: int
    portfolio_topn: int
    replace_threshold: float
    ma_type: str = "SMA"
    stop_loss_pct: float | None = None
    enable_data_sufficiency_check: bool = False

    @classmethod
    def from_values(
        cls,
        *,
        ma_days: Any = None,
        ma_month: Any = None,
        portfolio_topn: Any,
        replace_threshold: Any,
        ma_type: Any = None,
        stop_loss_pct: Any = None,
        enable_data_sufficiency_check: Any = False,
    ) -> StrategyRules:
        # MA ê¸°ê°„ ê²°ì • (ê°œì›” ìš°ì„ )
        final_ma_days = None

        if ma_month is not None:
            try:
                month_val = int(ma_month)
                if month_val > 0:
                    final_ma_days = month_val * TRADING_DAYS_PER_MONTH
            except (TypeError, ValueError):
                pass

        if final_ma_days is None and ma_days is not None:
            try:
                final_ma_days = int(ma_days)
            except (TypeError, ValueError):
                pass

        if final_ma_days is None or final_ma_days <= 0:
            if ma_days is None and ma_month is None:
                raise ValueError("MA_MONTHì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
            raise ValueError("MA_MONTHì€ 0ë³´ë‹¤ í° ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")

        try:
            portfolio_topn_int = int(portfolio_topn)
        except (TypeError, ValueError):
            raise ValueError("PORTFOLIO_TOPNì€ 0ë³´ë‹¤ í° ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.") from None
        if portfolio_topn_int <= 0:
            raise ValueError("PORTFOLIO_TOPNì€ 0ë³´ë‹¤ í° ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")

        try:
            replace_threshold_float = float(replace_threshold)
        except (TypeError, ValueError):
            raise ValueError("REPLACE_SCORE_THRESHOLDëŠ” ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤.") from None

        # MA íƒ€ì… ê²€ì¦
        ma_type_str = str(ma_type or cls.DEFAULT_MA_TYPE).upper()
        valid_ma_types = {"SMA", "EMA", "WMA", "DEMA", "TEMA", "HMA"}
        if ma_type_str not in valid_ma_types:
            raise ValueError(f"MA_TYPEì€ {valid_ma_types} ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤. (ì…ë ¥ê°’: {ma_type_str})")

        stop_loss_value: float | None = None
        if stop_loss_pct is not None:
            try:
                stop_loss_value = float(stop_loss_pct)
            except (TypeError, ValueError) as exc:
                raise ValueError("STOP_LOSS_PCTëŠ” ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤.") from exc
            if not (stop_loss_value > 0):
                raise ValueError("STOP_LOSS_PCTëŠ” 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.")

        # ENABLE_DATA_SUFFICIENCY_CHECK ê²€ì¦
        data_sufficiency_check = bool(enable_data_sufficiency_check)

        return cls(
            ma_days=final_ma_days,
            portfolio_topn=portfolio_topn_int,
            replace_threshold=replace_threshold_float,
            ma_type=ma_type_str,
            stop_loss_pct=stop_loss_value,
            enable_data_sufficiency_check=data_sufficiency_check,
        )

    @classmethod
    def from_mapping(cls, mapping: Mapping[str, Any]) -> StrategyRules:
        def _resolve(*keys: str) -> Any:
            sentinel = object()
            for key in keys:
                value = mapping.get(key, sentinel)
                if value is not sentinel:
                    return value
            return None

        return cls.from_values(
            ma_month=_resolve("MA_MONTH", "ma_month"),
            ma_days=_resolve("ma_days"),
            portfolio_topn=_resolve("PORTFOLIO_TOPN", "portfolio_topn"),
            replace_threshold=_resolve("REPLACE_SCORE_THRESHOLD", "replace_threshold"),
            ma_type=_resolve("MA_TYPE", "ma_type"),
            stop_loss_pct=_resolve("STOP_LOSS_PCT", "stop_loss_pct"),
            # ë°ì´í„° ì¶©ë¶„ì„± ê²€ì¦ í™œì„±í™” ì—¬ë¶€
            # True: ì‹ ê·œ ìƒì¥ ETF ë“± ë°ì´í„°ê°€ ë¶€ì¡±í•œ ê²½ìš° ì™„í™”ëœ ê¸°ì¤€ ì ìš©
            # False: ë°ì´í„° ì¶©ë¶„ì„± ê²€ì¦ ë¹„í™œì„±í™” (ëª¨ë“  ì¢…ëª©ì— ëŒ€í•´ ê³„ì‚° ì‹œë„)
            enable_data_sufficiency_check=_resolve("ENABLE_DATA_SUFFICIENCY_CHECK", "enable_data_sufficiency_check"),
        )

    def to_dict(self) -> dict[str, Any]:
        d = {
            "ma_days": self.ma_days,
            "portfolio_topn": self.portfolio_topn,
            "replace_threshold": self.replace_threshold,
            "ma_type": self.ma_type,
            "stop_loss_pct": self.stop_loss_pct,
            "enable_data_sufficiency_check": self.enable_data_sufficiency_check,
        }
        return d


__all__ = [
    "StrategyRules",
]
=== strategies/maps/scoring.py ===
"""MAPS ì „ëµ ì ìˆ˜ ê³„ì‚° ë° ì •ê·œí™” í•¨ìˆ˜."""

from __future__ import annotations

import numpy as np
import pandas as pd


def calculate_maps_score(
    close_prices: pd.Series,
    moving_average: pd.Series,
) -> pd.Series:
    """
    MAPS(Moving Average Position Score) ì ìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

    Args:
        close_prices: ì¢…ê°€ ì‹œë¦¬ì¦ˆ
        moving_average: ì´ë™í‰ê·  ì‹œë¦¬ì¦ˆ

    Returns:
        pd.Series: ì´ë™í‰ê·  ëŒ€ë¹„ ìˆ˜ìµë¥  (%)

    Examples:
        >>> close = pd.Series([110, 115, 120])
        >>> ma = pd.Series([100, 100, 100])
        >>> calculate_maps_score(close, ma)
        0    10.0
        1    15.0
        2    20.0
        dtype: float64
    """
    # 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
    safe_moving_average = moving_average.replace(0, np.nan)
    ma_score = ((close_prices / safe_moving_average) - 1.0) * 100
    # ë¬´í•œëŒ€ ê°’ ì²˜ë¦¬
    ma_score = ma_score.replace([np.inf, -np.inf], np.nan).fillna(0.0)

    return ma_score


__all__ = [
    "calculate_maps_score",
]
=== strategies/maps/evaluator.py ===
"""MAPS ì „ëµ ì˜ì‚¬ê²°ì • í‰ê°€ ëª¨ë“ˆ"""

import pandas as pd

from strategies.maps.constants import DECISION_MESSAGES, DECISION_NOTES


def _format_trend_break_phrase(ma_value: float | None, price_value: float | None, ma_days: int | None) -> str:
    if ma_value is None or pd.isna(ma_value) or price_value is None or pd.isna(price_value):
        threshold = ma_value if (ma_value is not None and not pd.isna(ma_value)) else 0.0
        return f"{DECISION_NOTES['TREND_BREAK']}({threshold:,.0f}ì› ì´í•˜)"

    diff = ma_value - price_value
    direction = "ë‚®ìŠµë‹ˆë‹¤" if diff >= 0 else "ë†’ìŠµë‹ˆë‹¤"
    period_text = ""
    if ma_days:
        try:
            period_text = f"{int(ma_days)}ì¼ "
        except (TypeError, ValueError):
            period_text = ""
    return (
        f"{DECISION_NOTES['TREND_BREAK']}"
        f"({period_text}í‰ê·  ê°€ê²© {ma_value:,.0f}ì› ë³´ë‹¤ {abs(diff):,.0f}ì› {direction}.)"
    )


def _calc_days_left(block_info: dict | None, cooldown_days: int | None) -> int | None:
    if not cooldown_days or cooldown_days <= 0 or not isinstance(block_info, dict):
        return None
    try:
        return max(cooldown_days - int(block_info.get("days_since", 0)) + 1, 0)
    except (TypeError, ValueError):
        return None


def _format_cooldown_message(days_left: int | None, action: str = "") -> str:
    if days_left is None:
        template = DECISION_NOTES.get("COOLDOWN_GENERIC", "ì¿¨ë‹¤ìš´ {days}ì¼ ëŒ€ê¸°ì¤‘")
        return template.replace("{days}", "?")

    if days_left > 0:
        template = DECISION_NOTES.get("COOLDOWN_GENERIC", "ì¿¨ë‹¤ìš´ {days}ì¼ ëŒ€ê¸°ì¤‘")
        base = template.replace("{days}", str(days_left))
        return f"{base} ({action})" if action else base
    else:
        template = DECISION_NOTES.get("COOLDOWN_GENERIC", "ì¿¨ë‹¤ìš´ {days}ì¼ ëŒ€ê¸°ì¤‘")
        return template.replace("{days}", "0")


class StrategyEvaluator:
    """MAPS ì „ëµì˜ ë§¤ìˆ˜/ë§¤ë„ ì˜ì‚¬ê²°ì •ì„ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤"""

    def __init__(self):
        pass

    def evaluate_sell_decision(
        self,
        current_state: str,
        price: float,
        avg_cost: float,
        highest_price: float,
        ma_value: float,
        ma_days: int,
        score: float,
        rsi_score: float,
        stop_loss_threshold: float | None,
        rsi_sell_threshold: float,
        sell_cooldown_info: dict | None,
        cooldown_days: int,
    ) -> tuple[str, str]:
        """
        ë§¤ë„ ì—¬ë¶€ë¥¼ íŒë‹¨í•©ë‹ˆë‹¤.

        Returns:
            (new_state, phrase)
        """
        phrase = ""
        new_state = current_state

        if current_state not in ("HOLD",):
            return current_state, phrase

        hold_ret = (price / avg_cost - 1.0) * 100.0 if avg_cost > 0 else 0.0

        if stop_loss_threshold is not None and hold_ret <= float(stop_loss_threshold):
            new_state = "CUT_STOPLOSS"
            phrase = DECISION_MESSAGES.get("CUT_STOPLOSS", "ì†ì ˆë§¤ë„")
        elif rsi_sell_threshold is not None and rsi_score >= rsi_sell_threshold:
            new_state = "SELL_RSI"
            phrase = f"RSI ê³¼ë§¤ìˆ˜ (RSIì ìˆ˜: {rsi_score:.1f})"
        elif score <= 0:
            new_state = "SELL_TREND"
            phrase = _format_trend_break_phrase(ma_value, price, ma_days)

        # ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ì¼ë°˜ ë§¤ë„(ì¶”ì„¸, RSI)ëŠ” HOLDë¡œ ìœ ì§€
        # ì†ì ˆì€ ì¿¨ë‹¤ìš´ ë¬´ì‹œ
        if sell_cooldown_info and new_state in ("SELL_RSI", "SELL_TREND"):
            days_left = _calc_days_left(sell_cooldown_info, cooldown_days)
            if days_left and days_left > 0:
                new_state = "HOLD"
                action = f"{days_left}ì¼ í›„ ë§¤ë„ ê°€ëŠ¥"
                phrase = _format_cooldown_message(days_left, action)

        return new_state, phrase

    def check_buy_signal(
        self,
        score: float,
        buy_cooldown_info: dict | None,
        cooldown_days: int,
    ) -> tuple[bool, str]:
        """
        ë§¤ìˆ˜ ì‹œê·¸ë„ ë°œìƒ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.

        Returns:
            (is_buy_signal, phrase)
        """
        from logic.backtest.signals import has_buy_signal

        if has_buy_signal(score, 0):
            if buy_cooldown_info:
                days_left = _calc_days_left(buy_cooldown_info, cooldown_days)
                if days_left and days_left > 0:
                    action = f"{days_left}ì¼ í›„ ë§¤ìˆ˜ ê°€ëŠ¥"
                    phrase = _format_cooldown_message(days_left, action)
                    return False, phrase
                else:
                    return True, "ì¿¨ë‹¤ìš´ ëŒ€ê¸°ì¤‘(ì˜¤ëŠ˜ ë§¤ìˆ˜ ê°€ëŠ¥)"
            return True, DECISION_MESSAGES.get("NEW_BUY", "")

        # ì ìˆ˜ ë¯¸ë‹¬ ë©”ì‹œì§€
        if pd.isna(score):
            return False, "ì¶”ì„¸ ì´íƒˆ (ì ìˆ˜ ì—†ìŒ)"
        return False, f"ì¶”ì„¸ ì´íƒˆ (í˜„ì¬ {score:.1f})"
=== strategies/maps/labeler.py ===
"""Shared labeler for signal/backtest to keep messages/states consistent."""

from __future__ import annotations

from typing import Any

from .constants import DECISION_MESSAGES
from .messages import build_partial_sell_note


def compute_net_trade_note(
    *,
    tkr: str,
    data_by_tkr: dict[str, Any],
    buy_trades_today_map: dict[str, list[dict[str, Any]]],
    sell_trades_today_map: dict[str, list[dict[str, Any]]],
    current_decision: str | None = None,
) -> dict[str, Any]:
    """Compute per-ticker net buy/sell note and state overrides for the day.

    Returns a dict possibly containing keys: state, row4, note.
    """
    trades_buys = buy_trades_today_map.get(tkr, [])
    total_buy_amount = (
        sum(float(tr.get("shares", 0.0) or 0.0) * float(tr.get("price", 0.0) or 0.0) for tr in trades_buys)
        if trades_buys
        else 0.0
    )

    sells = sell_trades_today_map.get(tkr, [])
    total_sold_amount = (
        sum(float(tr.get("shares", 0.0) or 0.0) * float(tr.get("price", 0.0) or 0.0) for tr in sells) if sells else 0.0
    )
    d = data_by_tkr.get(tkr) or {}
    current_shares_now = float(d.get("shares", 0.0) or 0.0)

    is_fully_sold = current_shares_now <= 0.0

    # ê±°ë˜ê°€ ì „í˜€ ì—†ìœ¼ë©´ ì•„ë¬´ ê²ƒë„ ë³€ê²½í•˜ì§€ ì•ŠìŒ (WAIT/HOLD ë“±ì´ SOLDë¡œ ë°”ë€Œì§€ ì•Šë„ë¡)
    if not trades_buys and not sells:
        return {}

    # SOLD override: ë‹¹ì¼ ë§¤ë„ê°€ ìˆì—ˆê³  í˜„ì¬ ë³´ìœ ê°€ 0ì¸ ê²½ìš°ì—ë§Œ SOLD ì²˜ë¦¬
    if is_fully_sold and sells and (current_decision in (None, "WAIT", "HOLD")):
        return {"state": "SOLD", "row4": "SOLD", "note": DECISION_MESSAGES["SOLD"]}

    net_amount = total_buy_amount - total_sold_amount
    if net_amount > 0:
        # net buy: ë¶€ë¶„/ì‹ ê·œ êµ¬ë¶„ ì—†ì´ ë™ì¼ ë©”ì‹œì§€ ì‚¬ìš©
        return {"note": DECISION_MESSAGES["NEW_BUY"]}
    if net_amount < 0:
        # net sell, keep HOLD state
        note = build_partial_sell_note()
        return {"state": "HOLD", "row4": "HOLD", "note": note}

    # net zero: no override
    return {}


__all__ = ["compute_net_trade_note"]
=== strategies/maps/metrics.py ===
"""MAPS ì „ëµ ì§€í‘œ ê³„ì‚° ëª¨ë“ˆ"""

from collections.abc import Mapping
from typing import Any

import pandas as pd

from config import MIN_TRADING_DAYS
from logic.backtest.signals import calculate_consecutive_days
from strategies.rsi.backtest import process_ticker_data_rsi
from utils.indicators import calculate_ma_score
from utils.moving_averages import calculate_moving_average


def process_ticker_data(
    ticker: str,
    df: pd.DataFrame,
    ma_days: int,
    precomputed_entry: Mapping[str, Any] | None = None,
    ma_type: str = "SMA",
    enable_data_sufficiency_check: bool = False,
) -> dict | None:
    """
    ê°œë³„ ì¢…ëª©ì˜ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê³  ì§€í‘œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

    Args:
        ticker: ì¢…ëª© í‹°ì»¤
        df: ê°€ê²© ë°ì´í„°í”„ë ˆì„
        ma_days: ì´ë™í‰ê·  ê¸°ê°„
        precomputed_entry: ë¯¸ë¦¬ ê³„ì‚°ëœ ìºì‹œ ë°ì´í„° (ì˜µì…˜)
        ma_type: ì´ë™í‰ê·  íƒ€ì… (SMA, EMA, WMA, DEMA, TEMA, HMA)
        enable_data_sufficiency_check: ë°ì´í„° ì¶©ë¶„ì„± ê²€ì‚¬ í™œì„±í™” ì—¬ë¶€

    Returns:
        Dict: ê³„ì‚°ëœ ì§€í‘œë“¤ ë˜ëŠ” None (ì²˜ë¦¬ ì‹¤íŒ¨ ì‹œ)
    """
    if df is None and precomputed_entry is None:
        return None
    if df is not None and df.empty and not precomputed_entry:
        return None

    working_df = df
    if working_df is None and precomputed_entry:
        # Dummy frame to keep downstream logic consistent
        working_df = pd.DataFrame()

    if working_df is not None and isinstance(working_df.columns, pd.MultiIndex):
        working_df = working_df.copy()
        working_df.columns = working_df.columns.get_level_values(0)
        working_df = working_df.loc[:, ~working_df.columns.duplicated()]

    # í‹°ì»¤ ìœ í˜•ì— ë”°ë¥¸ ì´ë™í‰ê·  ê¸°ê°„ ê²°ì • (ë‹¨ì¼ ê¸°ê°„ ì‚¬ìš©)
    current_ma_days = ma_days

    close_prices = None
    open_prices = None
    if isinstance(precomputed_entry, Mapping):
        close_prices = precomputed_entry.get("close")
        open_prices = precomputed_entry.get("open")

    if close_prices is None:
        if working_df is None:
            return None

        price_series = None
        if isinstance(working_df.columns, pd.MultiIndex):
            cols = working_df.columns.get_level_values(0)
            working_df = working_df.copy()
            working_df.columns = cols
            working_df = working_df.loc[:, ~working_df.columns.duplicated()]

        if "unadjusted_close" in working_df.columns:
            price_series = working_df["unadjusted_close"]
        else:
            price_series = working_df["Close"]

        if isinstance(price_series, pd.DataFrame):
            price_series = price_series.iloc[:, 0]
        close_prices = price_series.astype(float)

    if open_prices is None:
        if working_df is not None and "Open" in working_df.columns:
            open_series = working_df["Open"]
            if isinstance(open_series, pd.DataFrame):
                open_series = open_series.iloc[:, 0]
            open_prices = open_series.astype(float)
        else:
            open_prices = close_prices.copy()

    # ë°ì´í„° ì¶©ë¶„ì„± ê²€ì¦: MA íƒ€ì…ë³„ ì´ìƒì ì¸ ë°ì´í„° ìš”êµ¬ëŸ‰
    if enable_data_sufficiency_check:
        ma_type_upper = (ma_type or "SMA").upper()
        if ma_type_upper in {"EMA", "DEMA", "TEMA"}:
            ideal_multiplier = 2.0
        elif ma_type_upper == "HMA":
            ideal_multiplier = 1.5
        else:  # SMA, WMA ë“±
            ideal_multiplier = 1.0

        ideal_data_required = int(current_ma_days * ideal_multiplier)

        # ë°ì´í„°ê°€ ì´ìƒì ì¸ ì–‘ë³´ë‹¤ ì ìœ¼ë©´ ì™„í™”ëœ ê¸°ì¤€ ì ìš©
        if len(close_prices) < ideal_data_required:
            # ì™„í™”ëœ ê¸°ì¤€: multiplierì˜ ì ˆë°˜ (ìµœì†Œ 1ë°°)
            relaxed_multiplier = max(ideal_multiplier / 2.0, 1.0)
            min_required_data = int(current_ma_days * relaxed_multiplier)
        else:
            # ì¶©ë¶„í•œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì´ìƒì ì¸ ê¸°ì¤€ ì ìš©
            min_required_data = ideal_data_required

        if len(close_prices) < min_required_data:
            return None

    # ì ˆëŒ€ ìµœì†Œ ê±°ë˜ì¼ ê¸°ì¤€ (ENABLE_DATA_SUFFICIENCY_CHECKì™€ ë¬´ê´€, í•­ìƒ ì ìš©)
    if len(close_prices) < MIN_TRADING_DAYS:
        return None

    # MAPS ì „ëµ ì§€í‘œ ê³„ì‚°
    ma_type_key = (ma_type or "SMA").upper()
    ma_key = f"{ma_type_key}_{int(current_ma_days)}"
    moving_average = None
    ma_score = None
    if isinstance(precomputed_entry, Mapping):
        ma_cache = precomputed_entry.get("ma") or {}
        ma_score_cache = precomputed_entry.get("ma_score") or {}
        moving_average = ma_cache.get(ma_key)
        ma_score = ma_score_cache.get(ma_key)

    if moving_average is None:
        moving_average = calculate_moving_average(close_prices, current_ma_days, ma_type)
    if ma_score is None:
        ma_score = calculate_ma_score(close_prices, moving_average)

    # ì ìˆ˜ ê¸°ë°˜ ë§¤ìˆ˜ ì‹œê·¸ë„ ì§€ì†ì¼ ê³„ì‚°
    consecutive_buy_days = calculate_consecutive_days(ma_score)

    # RSI ì „ëµ ì§€í‘œ ê³„ì‚°
    rsi_score = None
    if isinstance(precomputed_entry, Mapping):
        rsi_score = precomputed_entry.get("rsi_score")
    if rsi_score is None or isinstance(rsi_score, float):
        rsi_data = process_ticker_data_rsi(close_prices)
        rsi_score = rsi_data.get("rsi_score") if rsi_data else pd.Series(dtype=float)

    return {
        "df": working_df if working_df is not None else df,
        "close": close_prices,
        "open": open_prices,
        "ma": moving_average,
        "ma_score": ma_score,
        "rsi_score": rsi_score,
        "buy_signal_days": consecutive_buy_days,
        "ma_days": current_ma_days,
    }
